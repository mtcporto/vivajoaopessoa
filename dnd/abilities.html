<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Habilidades e Magias - D&D 5e</title>
  <style>
    :root {
      --primary-color: #7b2cbf;
      --secondary-color: #e0aaff;
      --dark-color: #240046;
      --light-color: #f8f9fa;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      background-color: #f5f5f5;
      background-image: url('https://www.transparenttextures.com/patterns/parchment.png');
      color: #333;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .header h1 {
      color: var(--dark-color);
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .header p {
      font-size: 1.2rem;
      color: #666;
    }
    
    .character-info {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 30px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
    }
    
    .character-details {
      flex: 1;
      min-width: 300px;
    }
    
    .character-name {
      font-size: 1.8rem;
      color: var(--primary-color);
      margin-bottom: 5px;
    }
    
    .character-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin-bottom: 10px;
    }
    
    .character-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 10px;
    }
    
    .stat-item {
      background-color: var(--light-color);
      border-radius: 5px;
      padding: 8px 15px;
      font-weight: bold;
    }
    
    .stat-label {
      font-size: 0.8rem;
      color: #666;
      display: block;
    }
    
    .stat-value {
      font-size: 1.1rem;
      color: var(--dark-color);
    }
    
    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }
    
    .btn-primary:hover {
      background-color: var(--dark-color);
    }
    
    .btn-secondary {
      background-color: #6c757d;
      color: white;
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .tabs {
      display: flex;
      border-bottom: 2px solid var(--primary-color);
      margin-bottom: 20px;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #f1f1f1;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      margin-right: 5px;
      transition: all 0.3s ease;
    }
    
    .tab.active {
      background-color: var(--primary-color);
      color: white;
    }
    
    .tab:hover:not(.active) {
      background-color: var(--secondary-color);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .abilities-section, .spells-section {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .section-title {
      color: var(--dark-color);
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    
    .ability-group, .spell-level {
      margin-bottom: 25px;
    }
    
    .group-title {
      font-size: 1.3rem;
      color: var(--primary-color);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
    }
    
    .level-badge {
      background-color: var(--dark-color);
      color: white;
      font-size: 0.8rem;
      padding: 3px 8px;
      border-radius: 10px;
      margin-left: 10px;
    }
    
    .ability-list, .spell-list {
      list-style: none;
    }
    
    .ability-item, .spell-item {
      background-color: #f9f9f9;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #ddd;
      transition: all 0.3s ease;
    }
    
    .ability-item:hover, .spell-item:hover {
      transform: translateX(5px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .ability-item.available, .spell-item.available {
      border-left-color: var(--success-color);
    }
    
    .ability-item.unavailable, .spell-item.unavailable {
      border-left-color: var(--danger-color);
      opacity: 0.7;
    }
    
    .ability-name, .spell-name {
      font-weight: bold;
      font-size: 1.1rem;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
    }
    
    .ability-level, .spell-level-indicator {
      font-size: 0.8rem;
      color: #666;
      background-color: #eee;
      padding: 2px 8px;
      border-radius: 10px;
    }
    
    .ability-description, .spell-description {
      margin-top: 10px;
      font-size: 0.95rem;
    }
    
    .spell-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 5px;
      font-size: 0.9rem;
    }
    
    .spell-meta-item {
      background-color: #eee;
      padding: 3px 8px;
      border-radius: 5px;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid var(--primary-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .hidden {
      display: none;
    }
    
    .empty-message {
      text-align: center;
      padding: 30px;
      color: #666;
      font-style: italic;
    }
    
    .back-link {
      display: inline-block;
      margin-bottom: 20px;
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
    }
    
    .back-link:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 768px) {
      .character-info {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .character-stats {
        margin-top: 15px;
      }
      
      .tabs {
        flex-wrap: wrap;
      }
      
      .tab {
        flex: 1;
        text-align: center;
        min-width: 120px;
        margin-bottom: 5px;
      }
    }

    .feature-item, .trait-item, .spell-item {
      background-color: #f8f9fa;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .feature-name, .trait-name, .spell-name {
      color: #7b2cbf;
      margin-top: 0;
      margin-bottom: 10px;
    }
    
    .empty-message, .loading-message {
      color: #666;
      font-style: italic;
    }
    
    .locked-message {
      color: #dc3545;
      font-style: italic;
    }
    
    .locked {
      opacity: 0.7;
    }
    
    .spell-level {
      color: #7b2cbf;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
    
    .error-message {
      background-color: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 5px;
      margin: 20px;
      text-align: center;
    }
    
    .abilities-section, .spells-section {
      margin-bottom: 30px;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="personagem.html" class="back-link">← Back to Character Sheet</a>
    
    <div class="header">
      <h1>Abilities and Spells</h1>
      <p>Explore all abilities and spells available for your class</p>
    </div>
    
    <div id="character-info" class="character-info">
      <div class="character-details">
        <h2 id="character-name" class="character-name">Carregando...</h2>
        <div id="character-subtitle" class="character-subtitle"></div>
      </div>
      
      <div class="character-stats">
        <div class="stat-item">
          <span class="stat-label">Nível</span>
          <span id="character-level" class="stat-value">-</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Classe</span>
          <span id="character-class" class="stat-value">-</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Raça</span>
          <span id="character-race" class="stat-value">-</span>
        </div>
      </div>
    </div>
    
    <div class="tabs">
      <div class="tab" data-tab="abilities">Class Features</div>
      <div class="tab active" data-tab="spells">Spells</div>
      <div class="tab" data-tab="racial">Racial Traits</div>
    </div>
    
    <div id="abilities-tab" class="tab-content">
      <div class="abilities-section">
        <h2 class="section-title">Class Features</h2>
        <div id="features-container">
          <p class="empty-message">Loading features...</p>
        </div>
      </div>
    </div>
    
    <div id="spells-tab" class="tab-content active">
      <div class="spells-section">
        <h2 class="section-title">Spells</h2>
        <div id="spells-container">
          <p class="empty-message">Loading spells...</p>
        </div>
      </div>
    </div>
    
    <div id="racial-tab" class="tab-content">
      <div class="abilities-section">
        <h2 class="section-title">Racial Traits</h2>
        <div id="racial-container">
          <p class="empty-message">Loading racial traits...</p>
        </div>
      </div>
    </div>
  </div>
  
  <div id="loading" class="loading">
    <div class="loading-spinner"></div>
  </div>
  
  <script>
  // Cache for API data to reduce repeated requests
  const apiCache = {
    classFeatures: {},
    spells: {},
    raceFeatures: {}
  };
  
  // Show loading indicator
  function showLoading() {
    document.getElementById('loading').classList.remove('hidden');
  }
  
  // Hide loading indicator
  function hideLoading() {
    document.getElementById('loading').classList.add('hidden');
  }
  
  // Fetch data from API with error handling and caching
  async function fetchAPI(endpoint) {
    try {
      const response = await fetch(`https://www.dnd5eapi.co/api/${endpoint}`);
      if (!response.ok) {
        throw new Error(`Error fetching data: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`API Error: ${error.message}`);
      return null;
    }
  }
  
  // Function to get spell slots based on class and level
  function getSpellSlots(characterClass, level) {
    const className = characterClass && typeof characterClass === 'string' 
      ? characterClass.toLowerCase() 
      : '';
    
    console.log(`Getting spell slots for class: ${className}, level: ${level}`);
    
    // Spell slot tables by class and level
    const spellSlotsByClass = {
      'bard': {
        1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 3, 2, 0, 0, 0, 0, 0, 0]
      },
      'cleric': {
        1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 3, 2, 0, 0, 0, 0, 0, 0]
      },
      'druid': {
        1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 3, 2, 0, 0, 0, 0, 0, 0]
      },
      'paladin': {
        1: [0, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        4: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      'ranger': {
        1: [0, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        4: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      'sorcerer': {
        1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 3, 2, 0, 0, 0, 0, 0, 0]
      },
      'warlock': {
        1: [1, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [0, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [0, 2, 0, 0, 0, 0, 0, 0, 0],
        5: [0, 0, 2, 0, 0, 0, 0, 0, 0]
      },
      'wizard': {
        1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
        5: [4, 3, 2, 0, 0, 0, 0, 0, 0]
      }
    };
    
    // Return default empty array if class not found or level not valid
    if (!spellSlotsByClass[className] || !spellSlotsByClass[className][level]) {
      console.warn(`No spell slots found for ${className} level ${level}`);
      return [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    
    return spellSlotsByClass[className][level];
  }
  
  // Initialize page
  async function initializePage() {
    showLoading();
    
    try {
      // Load character from localStorage
      const characterData = localStorage.getItem('currentCharacter');
      if (!characterData) {
        alert('No character found. Please return to character sheet and create a character first.');
        window.location.href = 'personagem.html';
        return;
      }
      
      const character = JSON.parse(characterData);
      console.log("Character data loaded:", character);
      console.log("Character spells:", character.spells);
      
      // Update character info in the interface
      updateCharacterInfo(character);
      
      // Always fetch class features from API
      await loadClassFeatures(character.class, character.level);
      
      // Load spells directly from character
      loadSpells(character);
      
      // Always fetch racial traits from API
      await loadRacialFeatures(character.race);
      
      // Setup tabs
      setupTabs();
      
      hideLoading();
    } catch (error) {
      console.error('Error initializing page:', error);
      hideLoading();
      alert('An error occurred while loading data. Please try again.');
    }
  }
  
  // Update character information in the UI
  function updateCharacterInfo(character) {
    document.getElementById('character-name').textContent = character.name;
    document.getElementById('character-subtitle').textContent = `${character.race} ${character.class}`;
    document.getElementById('character-level').textContent = character.level;
    document.getElementById('character-class').textContent = character.class;
    document.getElementById('character-race').textContent = character.race;
  }
  
  // Load class features from API
  async function loadClassFeatures(className, characterLevel) {
    const container = document.getElementById('features-container');
    if (!container) {
      console.error("Features container not found!");
      return;
    }
    container.innerHTML = '<p class="empty-message">Loading class features...</p>';
    
    try {
      // Check cache
      const cacheKey = `${className.toLowerCase()}_features`;
      let classFeatures = apiCache.classFeatures[cacheKey];
      
      if (!classFeatures) {
        // Get class data
        const classData = await fetchAPI(`classes/${className.toLowerCase()}`);
        if (!classData) {
          throw new Error('Could not load class data.');
        }
        
        // Get class levels
        const classLevels = await fetchAPI(`classes/${className.toLowerCase()}/levels`);
        if (!classLevels || !Array.isArray(classLevels)) {
          throw new Error('Could not load class levels.');
        }
        
        // Organize features by level
        classFeatures = {};
        
        classLevels.forEach(level => {
          if (level.features && Array.isArray(level.features)) {
            classFeatures[level.level] = level.features.map(feature => ({
              name: feature.name,
              index: feature.index,
              level: level.level,
              url: feature.url,
              desc: feature.desc || `${className} feature for level ${level.level}`
            }));
          } else {
            classFeatures[level.level] = [];
          }
        });
        
        // Save to cache
        apiCache.classFeatures[cacheKey] = classFeatures;
      }
      
      // Generate HTML for features
      let html = '';
      
      // Check if there are features
      const hasFeatures = Object.values(classFeatures).some(levelFeatures => 
        levelFeatures && levelFeatures.length > 0
      );
      
      if (hasFeatures) {
        // Group by level
        for (let level = 1; level <= 20; level++) {
          const levelFeatures = classFeatures[level] || [];
          
          if (levelFeatures.length > 0) {
            html += `
              <div class="ability-group">
                <h3 class="group-title">Level ${level} <span class="level-badge">${level <= characterLevel ? 'Available' : 'Locked'}</span></h3>
                <ul class="ability-list">
            `;
            
            // Add each feature
            for (const feature of levelFeatures) {
              const isAvailable = level <= characterLevel;
              
              html += `
                <li class="ability-item ${isAvailable ? 'available' : 'unavailable'}">
                  <div class="ability-name">
                    ${feature.name}
                    <span class="ability-level">Level ${level}</span>
                  </div>
                  <div class="ability-description">${feature.desc || 'No description available.'}</div>
                </li>
              `;
            }
            
            html += `
                </ul>
              </div>
            `;
          }
        }
      } else {
        html = '<p class="empty-message">No features found for this class.</p>';
      }
      
      container.innerHTML = html;
    } catch (error) {
      console.error('Error loading class features:', error);
      container.innerHTML = '<p class="empty-message">Error loading features. Please try again.</p>';
    }
  }
  
  // Load spells
  function loadSpells(character) {
    const container = document.getElementById('spells-container');
    if (!container) {
      console.error("Spells container not found!");
      return;
    }
    
    container.innerHTML = '';
    
    // Check if character has spells array
    if (!character.spells || !Array.isArray(character.spells) || character.spells.length === 0) {
      container.innerHTML = '<p class="empty-message">This character does not have any spells.</p>';
      return;
    }
    
    console.log("Found spells:", character.spells);
    
    // Get spell slots based on class and level
    const spellSlots = getSpellSlots(character.class, character.level);
    
    // Group spells by level
    const spellsByLevel = {};
    character.spells.forEach(spell => {
      const level = spell.level || 1;
      if (!spellsByLevel[level]) {
        spellsByLevel[level] = [];
      }
      spellsByLevel[level].push(spell);
    });
    
    // Create spell sections for each level
    Object.keys(spellsByLevel).sort((a, b) => a - b).forEach(level => {
      const levelInt = parseInt(level);
      const spells = spellsByLevel[level];
      
      const levelContainer = document.createElement('div');
      levelContainer.className = 'spell-level-section';
      
      // Determine slots available for this spell level
      let slots = 0;
      if (levelInt > 0 && levelInt <= 9) {
        slots = spellSlots[levelInt - 1];
      }
      
      const levelName = levelInt === 0 ? "Cantrips" : `Level ${level} Spells`;
      
      let header = document.createElement('h3');
      header.className = slots > 0 || levelInt === 0 ? 'available' : 'locked';
      
      if (levelInt === 0) {
        header.textContent = "Cantrips (Level 0)";
      } else {
        header.textContent = `${levelName} (Slots: ${slots})`;
      }
      
      levelContainer.appendChild(header);
      
      const spellList = document.createElement('ul');
      spellList.className = 'spell-list';
      
      // Add each spell to the list
      spells.forEach(spell => {
        const spellItem = document.createElement('li');
        spellItem.className = 'spell-item';
        
        const nameElement = document.createElement('h4');
        nameElement.className = 'spell-name';
        nameElement.textContent = spell.name;
        
        const descElement = document.createElement('div');
        descElement.className = 'spell-description';
        
        // Build comprehensive description
        let description = spell.description || '';
        
        // Add damage information if available
        if (spell.damage_dice) {
          description += `<p><strong>Damage:</strong> ${spell.damage_dice}`;
          if (spell.damage_type) {
            description += ` ${spell.damage_type}`;
          }
          description += '</p>';
        }
        
        // Add healing information if available
        if (spell.healing_dice) {
          description += `<p><strong>Healing:</strong> ${spell.healing_dice}`;
          if (spell.healing_bonus) {
            description += ` + ${spell.healing_bonus}`;
          }
          description += '</p>';
        }
        
        // If we still don't have a description
        if (!description) {
          description = 'No description available.';
        }
        
        descElement.innerHTML = description;
        
        spellItem.appendChild(nameElement);
        spellItem.appendChild(descElement);
        spellList.appendChild(spellItem);
      });
      
      levelContainer.appendChild(spellList);
      container.appendChild(levelContainer);
    });
    
    // If no spell sections were added, show a message
    if (container.childNodes.length === 0) {
      container.innerHTML = '<p class="empty-message">No spells found for this character.</p>';
    }
  }
  
  // Load racial traits from API
  async function loadRacialFeatures(raceName) {
    const container = document.getElementById('racial-container');
    if (!container) {
      console.error("Racial traits container not found!");
      return;
    }
    
    container.innerHTML = '<p class="empty-message">Loading racial traits...</p>';
    console.log(`Loading racial traits for ${raceName}`);
    
    try {
      // Check cache
      const cacheKey = `${raceName.toLowerCase()}_features`;
      let raceFeatures = apiCache.raceFeatures[cacheKey];
      
      if (!raceFeatures) {
        // Fetch race data from API
        const raceData = await fetchAPI(`races/${raceName.toLowerCase()}`);
        if (!raceData) {
          throw new Error('Could not load race data.');
        }
        
        // Extract trait indices from race data
        const traitReferences = raceData.traits || [];
        
        // Fetch full trait data for each trait
        raceFeatures = [];
        
        // Process each trait
        for (const traitRef of traitReferences) {
          if (traitRef.index) {
            const traitData = await fetchAPI(`traits/${traitRef.index}`);
            if (traitData) {
              raceFeatures.push({
                name: traitData.name,
                description: traitData.desc.join(' ') || 'No description available'
              });
            }
          }
        }
        
        // Save to cache
        apiCache.raceFeatures[cacheKey] = raceFeatures;
      }
      
      // Display racial traits
      if (raceFeatures && raceFeatures.length > 0) {
        let html = `
          <div class="ability-group">
            <h3 class="group-title">${raceName} Traits</h3>
            <ul class="ability-list">
        `;
        
        raceFeatures.forEach(feature => {
          html += `
            <li class="ability-item available">
              <div class="ability-name">
                ${feature.name}
              </div>
              <div class="ability-description">${feature.description}</div>
            </li>
          `;
        });
        
        html += `
            </ul>
          </div>
        `;
        
        container.innerHTML = html;
      } else {
        container.innerHTML = '<p class="empty-message">No racial traits found for this race.</p>';
      }
      
    } catch (error) {
      console.error('Error loading racial traits:', error);
      container.innerHTML = '<p class="empty-message">Error loading racial traits. Please try again.</p>';
    }
  }
  
  // Set up tabs functionality
  function setupTabs() {
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        
        // Add active class to clicked tab
        tab.classList.add('active');
        
        // Show corresponding content
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(`${tabId}-tab`).classList.add('active');
      });
    });
  }
  
  // Initialize the page when DOM is loaded
  document.addEventListener('DOMContentLoaded', initializePage);
</script>

</body>
</html>
